{"version":3,"sources":["@traceur/generated/TemplateParser/5","src/rtts_assert.es6","@traceur/generated/TemplateParser/8","@traceur/generated/TemplateParser/9","@traceur/generated/TemplateParser/7","@traceur/generated/TemplateParser/4","@traceur/generated/TemplateParser/6","src/rtts_assert.js"],"names":[],"mappings":"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","file":"src/rtts_assert.js","sourceRoot":"/Users/deast/Angular/quickstart/node_modules/rtts_assert/es6/","sourcesContent":["System.register($__placeholder__0, function($__export) {\n          $__placeholder__1\n        });","var _global = typeof window === 'object' ? window : global;\n\n// TODO(vojta):\n// - extract into multiple files\n// - different error types\n// - simplify/humanize error messages\n// - throw when invalid input (such as odd number of args into assert.argumentTypes)\n\nvar POSITION_NAME = ['', '1st', '2nd', '3rd'];\nfunction argPositionName(i) {\n  var position = (i / 2) + 1;\n\n  return POSITION_NAME[position] || (position + 'th');\n}\n\nvar primitives;\nvar genericType;\n\nif (typeof $traceurRuntime === 'object') {\n  primitives = $traceurRuntime.type;\n  genericType = $traceurRuntime.genericType;\n} else {\n  // Allow to work without traceur runtime as well!\n  primitives = {\n    any: {name: 'any'},\n    boolean: {name: 'boolean'},\n    number: {name: 'number'},\n    string: {name: 'string'},\n    symbol: {name: 'symbol'},\n    void: {name: 'void'}\n  };\n  genericType = function(type, args) {\n    return {\n      type: type,\n      args: args\n    }\n  }\n}\nObject.keys(primitives).forEach(function(name) {\n  primitives[name].__assertName = name;\n});\n\nexport function proxy(){\n}\n\nfunction assertArgumentTypes(...params) {\n  var actual, type;\n  var currentArgErrors;\n  var errors = [];\n  var msg;\n\n  for (var i = 0, l = params.length; i < l; i = i + 2) {\n    actual = params[i];\n    type = params[i + 1];\n\n    currentArgErrors = [];\n\n    // currentStack = [];\n    //\n\n    if (!isType(actual, type, currentArgErrors)) {\n\n      // console.log(JSON.stringify(errors, null, '  '));\n      // TODO(vojta): print \"an instance of\" only if T starts with uppercase.\n      errors.push(argPositionName(i) + ' argument has to be an instance of ' + prettyPrint(type) + ', got ' + prettyPrint(actual));\n      if (currentArgErrors.length) {\n        errors.push(currentArgErrors);\n      }\n    }\n  }\n\n  if (errors.length) {\n    throw new Error('Invalid arguments given!\\n' + formatErrors(errors));\n  }\n}\n\nfunction prettyPrint(value, depth) {\n  if (typeof(depth) === 'undefined') {\n    depth = 0;\n  }\n\n  if (depth++ > 3) {\n    return '[...]';\n  }\n\n  if (typeof value === 'undefined') {\n    return 'undefined';\n  }\n\n  if (typeof value === 'string') {\n    return '\"' + value + '\"';\n  }\n\n  if (typeof value === 'boolean') {\n    return value.toString();\n  }\n\n  if (value === null) {\n    return 'null';\n  }\n\n  if (typeof value === 'object') {\n    if (value.__assertName) {\n      return value.__assertName;\n    }\n\n    if (value.map && typeof value.map === 'function') {\n      return '[' + value.map((v) => prettyPrint(v, depth)).join(', ') + ']';\n    }\n\n    var properties = Object.keys(value);\n    var suffix = '}';\n    if (properties.length > 20) {\n      properties.length = 20;\n      suffix = ', ... }';\n    }\n    return '{' + properties.map((p) => p + ': ' + prettyPrint(value[p], depth)).join(', ') + suffix;\n  }\n\n  return value.__assertName || value.name || value.toString();\n}\n\nfunction isType(value, T, errors) {\n  if (T && T.type) {\n    // needed for generics.\n    // TODO(tbosch): read out T.args and do assertions based on them as well!\n    T = T.type;\n  }\n  if (T === primitives.void) {\n    return typeof value === 'undefined';\n  }\n\n  if (_isProxy(value)) {\n    return true;\n  }\n\n  if (T === primitives.any || value === null) {\n    return true;\n  }\n\n  if (T === primitives.string) {\n    return typeof value === 'string';\n  }\n\n  if (T === primitives.number) {\n    return typeof value === 'number';\n  }\n\n  if (T === primitives.boolean) {\n    return typeof value === 'boolean';\n  }\n\n  // var parentStack = currentStack;\n  // currentStack = [];\n\n  // shouldnt this create new stack?\n  if (typeof T.assert === 'function') {\n    var parentStack = currentStack;\n    var isValid;\n    currentStack = errors;\n    try {\n      isValid = T.assert(value) ;\n    } catch (e) {\n      fail(e.message);\n      isValid = false;\n    }\n\n    currentStack = parentStack;\n\n    if (typeof isValid === 'undefined') {\n      isValid = errors.length === 0;\n    }\n\n    return isValid;\n\n    // if (!currentStack.length) {\n    //   currentStack = parentStack;\n    //   return [];\n    // }\n    // var res = currentStack;\n    // currentStack = parentStack;\n    // return ['not instance of ' + prettyPrint(T), res];\n  }\n\n  return value instanceof T;\n\n  // if (!(value instanceof T)) {\n  //   fail('not instance of ' + prettyPrint(T));\n  // }\n\n  // var res = currentStack;\n  // currentStack = parentStack;\n\n  // return res;\n}\n\nfunction _isProxy(obj) {\n  if (!obj || !obj.constructor || !obj.constructor.annotations) return false;\n  return obj.constructor.annotations.filter((a) => a instanceof proxy).length > 0;\n}\n\nfunction formatErrors(errors, indent = '  ') {\n  return errors.map((e) => {\n    if (typeof e === 'string') return indent + '- ' + e;\n    return formatErrors(e, indent + '  ');\n  }).join('\\n');\n}\n\n\n// assert a type of given value and throw if does not pass\nfunction type(actual, T) {\n  var errors = [];\n  // currentStack = [];\n\n  if (!isType(actual, T, errors)) {\n    // console.log(JSON.stringify(errors, null, '  '));\n    // TODO(vojta): print \"an instance of\" only if T starts with uppercase.\n    var msg = 'Expected an instance of ' + prettyPrint(T) + ', got ' + prettyPrint(actual) + '!';\n    if (errors.length) {\n      msg += '\\n' + formatErrors(errors);\n    }\n\n    throw new Error(msg);\n  }\n  return actual;\n}\n\nfunction returnType(actual, T) {\n  var errors = [];\n  // currentStack = [];\n\n  if (!isType(actual, T, errors)) {\n    // console.log(JSON.stringify(errors, null, '  '));\n    // TODO(vojta): print \"an instance of\" only if T starts with uppercase.\n    var msg = 'Expected to return an instance of ' + prettyPrint(T) + ', got ' + prettyPrint(actual) + '!';\n    if (errors.length) {\n      msg += '\\n' + formatErrors(errors);\n    }\n\n    throw new Error(msg);\n  }\n\n  return actual;\n}\n\n// TODO(vojta): define these with DSL?\nvar string = type.string = define('string', function(value) {\n  return typeof value === 'string';\n});\n\nvar boolean = type.boolean = define('boolean', function(value) {\n  return typeof value === 'boolean';\n});\n\nvar number = type.number = define('number', function(value) {\n  return typeof value === 'number';\n});\n\nfunction arrayOf(...types) {\n  return assert.define('array of ' + types.map(prettyPrint).join('/'), function(value) {\n    if (assert(value).is(Array)) {\n      for (var i = 0; i < value.length; i++) {\n        assert(value[i]).is(...types);\n      }\n    }\n  });\n}\n\nfunction structure(definition) {\n  var properties = Object.keys(definition);\n  return assert.define('object with properties ' + properties.join(', '), function(value) {\n    if (assert(value).is(Object)) {\n      for (var i = 0; i < properties.length; i++) {\n        var property = properties[i];\n        assert(value[property]).is(definition[property]);\n      }\n    }\n  })\n}\n\n\n\n// I'm sorry, bad global state... to make the API nice ;-)\nvar currentStack = [];\n\nfunction fail(message) {\n  currentStack.push(message);\n}\n\nfunction define(classOrName, check) {\n  var cls = classOrName;\n\n  if (typeof classOrName === 'string') {\n    cls = function() {};\n    cls.__assertName = classOrName;\n  }\n\n  cls.assert = function(value) {\n    // var parentStack = currentStack;\n\n    // currentStack = [];\n\n    return check(value);\n\n    // if (currentStack.length) {\n    //   parentStack.push(currentStack)\n    // }\n    // currentStack = parentStack;\n  };\n\n  return cls;\n}\n\n\n\nfunction assert(value) {\n  return {\n    is: function is(...types) {\n      // var errors = []\n      var allErrors = [];\n      var errors;\n      for (var i = 0; i < types.length; i++) {\n        var type = types[i];\n        errors = [];\n\n        if (isType(value, type, errors)) {\n          return true;\n        }\n\n        // if no errors, merge multiple \"is not instance of \" into x/y/z ?\n        allErrors.push(prettyPrint(value) + ' is not instance of ' + prettyPrint(type))\n        if (errors.length) {\n          allErrors.push(errors);\n        }\n      }\n\n      // if (types.length > 1) {\n      //   currentStack.push(['has to be ' + types.map(prettyPrint).join(' or '), ...allErrors]);\n      // } else {\n        currentStack.push(...allErrors);\n      // }\n      return false;\n    }\n  };\n}\n\n\n// PUBLIC API\n\n// asserting API\n\n// throw if no type provided\nassert.type = type;\nfor (var prop in primitives) {\n  assert.type[prop] = primitives[prop];\n}\nassert.genericType = genericType;\n\n// throw if odd number of args\nassert.argumentTypes = assertArgumentTypes;\nassert.returnType = returnType;\n\n\n// define AP;\nassert.define = define;\nassert.fail = fail;\n\n// primitive value type;\nassert.string = string;\nassert.number = number;\nassert.boolean = boolean;\n\n// custom types\nassert.arrayOf = arrayOf;\nassert.structure = structure;\n\n\nexport {assert}\n","\n            for (var $__placeholder__0 = [], $__placeholder__1 = 0;\n                 $__placeholder__2 < arguments.length; $__placeholder__3++)\n              $__placeholder__4[$__placeholder__5] = arguments[$__placeholder__6];","$traceurRuntime.spread($__placeholder__0)","\n        $__export($__placeholder__0, $__placeholder__1)\n      ","return {\n      setters: $__placeholder__0,\n      execute: $__placeholder__1\n    }","$__export($__placeholder__0, $__placeholder__1);","var _global = typeof window === 'object' ? window : global;\nvar POSITION_NAME = ['', '1st', '2nd', '3rd'];\nfunction argPositionName(i) {\n  var position = (i / 2) + 1;\n  return POSITION_NAME[position] || (position + 'th');\n}\nvar primitives;\nvar genericType;\nif (typeof $traceurRuntime === 'object') {\n  primitives = $traceurRuntime.type;\n  genericType = $traceurRuntime.genericType;\n} else {\n  primitives = {\n    any: {name: 'any'},\n    boolean: {name: 'boolean'},\n    number: {name: 'number'},\n    string: {name: 'string'},\n    symbol: {name: 'symbol'},\n    void: {name: 'void'}\n  };\n  genericType = function(type, args) {\n    return {\n      type: type,\n      args: args\n    };\n  };\n}\nObject.keys(primitives).forEach(function(name) {\n  primitives[name].__assertName = name;\n});\nexport function proxy() {}\nfunction assertArgumentTypes(...params) {\n  var actual,\n      type;\n  var currentArgErrors;\n  var errors = [];\n  var msg;\n  for (var i = 0,\n      l = params.length; i < l; i = i + 2) {\n    actual = params[i];\n    type = params[i + 1];\n    currentArgErrors = [];\n    if (!isType(actual, type, currentArgErrors)) {\n      errors.push(argPositionName(i) + ' argument has to be an instance of ' + prettyPrint(type) + ', got ' + prettyPrint(actual));\n      if (currentArgErrors.length) {\n        errors.push(currentArgErrors);\n      }\n    }\n  }\n  if (errors.length) {\n    throw new Error('Invalid arguments given!\\n' + formatErrors(errors));\n  }\n}\nfunction prettyPrint(value, depth) {\n  if (typeof(depth) === 'undefined') {\n    depth = 0;\n  }\n  if (depth++ > 3) {\n    return '[...]';\n  }\n  if (typeof value === 'undefined') {\n    return 'undefined';\n  }\n  if (typeof value === 'string') {\n    return '\"' + value + '\"';\n  }\n  if (typeof value === 'boolean') {\n    return value.toString();\n  }\n  if (value === null) {\n    return 'null';\n  }\n  if (typeof value === 'object') {\n    if (value.__assertName) {\n      return value.__assertName;\n    }\n    if (value.map && typeof value.map === 'function') {\n      return '[' + value.map((v) => prettyPrint(v, depth)).join(', ') + ']';\n    }\n    var properties = Object.keys(value);\n    var suffix = '}';\n    if (properties.length > 20) {\n      properties.length = 20;\n      suffix = ', ... }';\n    }\n    return '{' + properties.map((p) => p + ': ' + prettyPrint(value[p], depth)).join(', ') + suffix;\n  }\n  return value.__assertName || value.name || value.toString();\n}\nfunction isType(value, T, errors) {\n  if (T && T.type) {\n    T = T.type;\n  }\n  if (T === primitives.void) {\n    return typeof value === 'undefined';\n  }\n  if (_isProxy(value)) {\n    return true;\n  }\n  if (T === primitives.any || value === null) {\n    return true;\n  }\n  if (T === primitives.string) {\n    return typeof value === 'string';\n  }\n  if (T === primitives.number) {\n    return typeof value === 'number';\n  }\n  if (T === primitives.boolean) {\n    return typeof value === 'boolean';\n  }\n  if (typeof T.assert === 'function') {\n    var parentStack = currentStack;\n    var isValid;\n    currentStack = errors;\n    try {\n      isValid = T.assert(value);\n    } catch (e) {\n      fail(e.message);\n      isValid = false;\n    }\n    currentStack = parentStack;\n    if (typeof isValid === 'undefined') {\n      isValid = errors.length === 0;\n    }\n    return isValid;\n  }\n  return value instanceof T;\n}\nfunction _isProxy(obj) {\n  if (!obj || !obj.constructor || !obj.constructor.annotations)\n    return false;\n  return obj.constructor.annotations.filter((a) => a instanceof proxy).length > 0;\n}\nfunction formatErrors(errors, indent = '  ') {\n  return errors.map((e) => {\n    if (typeof e === 'string')\n      return indent + '- ' + e;\n    return formatErrors(e, indent + '  ');\n  }).join('\\n');\n}\nfunction type(actual, T) {\n  var errors = [];\n  if (!isType(actual, T, errors)) {\n    var msg = 'Expected an instance of ' + prettyPrint(T) + ', got ' + prettyPrint(actual) + '!';\n    if (errors.length) {\n      msg += '\\n' + formatErrors(errors);\n    }\n    throw new Error(msg);\n  }\n  return actual;\n}\nfunction returnType(actual, T) {\n  var errors = [];\n  if (!isType(actual, T, errors)) {\n    var msg = 'Expected to return an instance of ' + prettyPrint(T) + ', got ' + prettyPrint(actual) + '!';\n    if (errors.length) {\n      msg += '\\n' + formatErrors(errors);\n    }\n    throw new Error(msg);\n  }\n  return actual;\n}\nvar string = type.string = define('string', function(value) {\n  return typeof value === 'string';\n});\nvar boolean = type.boolean = define('boolean', function(value) {\n  return typeof value === 'boolean';\n});\nvar number = type.number = define('number', function(value) {\n  return typeof value === 'number';\n});\nfunction arrayOf(...types) {\n  return assert.define('array of ' + types.map(prettyPrint).join('/'), function(value) {\n    if (assert(value).is(Array)) {\n      for (var i = 0; i < value.length; i++) {\n        assert(value[i]).is(...types);\n      }\n    }\n  });\n}\nfunction structure(definition) {\n  var properties = Object.keys(definition);\n  return assert.define('object with properties ' + properties.join(', '), function(value) {\n    if (assert(value).is(Object)) {\n      for (var i = 0; i < properties.length; i++) {\n        var property = properties[i];\n        assert(value[property]).is(definition[property]);\n      }\n    }\n  });\n}\nvar currentStack = [];\nfunction fail(message) {\n  currentStack.push(message);\n}\nfunction define(classOrName, check) {\n  var cls = classOrName;\n  if (typeof classOrName === 'string') {\n    cls = function() {};\n    cls.__assertName = classOrName;\n  }\n  cls.assert = function(value) {\n    return check(value);\n  };\n  return cls;\n}\nfunction assert(value) {\n  return {is: function is(...types) {\n      var allErrors = [];\n      var errors;\n      for (var i = 0; i < types.length; i++) {\n        var type = types[i];\n        errors = [];\n        if (isType(value, type, errors)) {\n          return true;\n        }\n        allErrors.push(prettyPrint(value) + ' is not instance of ' + prettyPrint(type));\n        if (errors.length) {\n          allErrors.push(errors);\n        }\n      }\n      currentStack.push(...allErrors);\n      return false;\n    }};\n}\nassert.type = type;\nfor (var prop in primitives) {\n  assert.type[prop] = primitives[prop];\n}\nassert.genericType = genericType;\nassert.argumentTypes = assertArgumentTypes;\nassert.returnType = returnType;\nassert.define = define;\nassert.fail = fail;\nassert.string = string;\nassert.number = number;\nassert.boolean = boolean;\nassert.arrayOf = arrayOf;\nassert.structure = structure;\nexport {assert};\n\n//# sourceMappingURL=/Users/tbosch/projects/temp/angular2_clone/modules/rtts_assert/src/rtts_assert.map\n\n//# sourceMappingURL=./rtts_assert.map"]}