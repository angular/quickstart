{"version":3,"sources":["@traceur/generated/TemplateParser/5","@traceur/generated/TemplateParser/4","@traceur/generated/TemplateParser/3","@traceur/generated/TemplateParser/9","@traceur/generated/TemplateParser/6","@traceur/generated/TemplateParser/12","src/core/annotations/annotations.js","@traceur/generated/TemplateParser/11","src/core/annotations/@traceur/generated/TemplateParser/24","src/core/annotations/@traceur/generated/TemplateParser/23","@traceur/generated/TemplateParser/16","@traceur/generated/TemplateParser/7"],"names":[],"mappings":"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","file":"src/core/annotations/annotations.js","sourceRoot":"/Users/deast/Angular/quickstart/node_modules/angular2/es6/prod/","sourcesContent":["System.register($__placeholder__0, function($__export) {\n          $__placeholder__1\n        });","return {\n      setters: $__placeholder__0,\n      execute: $__placeholder__1\n    }","function($__m) {\n          $__placeholder__0\n        }","$__placeholder__0 = $__m.$__placeholder__1;","var $__placeholder__0 = $__export($__placeholder__1, $__placeholder__2);","function($__super) {\n          var $__placeholder__0 = $__placeholder__1;\n          return ($traceurRuntime.createClass)($__placeholder__2, $__placeholder__3,\n                                               $__placeholder__4, $__super);\n        }($__placeholder__5)","import {ABSTRACT, CONST, normalizeBlank, isPresent} from 'angular2/src/facade/lang';\nimport {ListWrapper, List} from 'angular2/src/facade/collection';\nimport {Injectable} from 'angular2/di';\n\n// type StringMap = {[idx: string]: string};\n\n/**\n * Directives allow you to attach behavior to elements in the DOM.\n *\n * Directive is an abstract concept, instead use concrete directives: [Component], [DynamicComponent], [Decorator]\n * or [Viewport].\n *\n * A directive consists of a single directive annotation and a controller class. When the directive's [selector] matches\n * elements in the DOM, the following steps occur:\n *\n * 1. For each directive, the [ElementInjector] attempts to resolve the directive's constructor arguments.\n * 2. Angular instantiates directives for each matched element using [ElementInjector] in a depth-first order,\n *    as declared in the HTML.\n *\n * ## Understanding How Injection Works\n *\n * There are three stages of injection resolution.\n * - *Pre-existing Injectors*:\n *   - The terminal [Injector] cannot resolve dependencies. It either throws an error or, if the dependency was\n *     specified as `@Optional`, returns `null`.\n *   - The primordial injector resolves browser singleton resources, such as: cookies, title, location, and others.\n * - *Component Injectors*: Each `@Component` has its own [Injector], and they follow the same parent-child hierachy\n *     as the components in the DOM.\n * - *Element Injectors*: Each component has a Shadow DOM. Within the Shadow DOM each element has an [ElementInjector]\n *  which follow the same parent-child hiercachy as the DOM elements themselves.\n *\n * When a template is instantiated, it also must instantiate the corresponding directives in a depth-first order. The\n * current [ElementInjector] resolves the constructor dependencies for each directive.\n *\n * Angular then resolves dependencies as follows, according to the order in which they appear in the [View]:\n *\n * 1. Dependencies on the current element\n * 2. Dependencies on element injectors and their parents until it encounters a Shadow DOM boundary\n * 3. Dependencies on component injectors and their parents until it encounters the root component\n * 4. Dependencies on pre-existing injectors\n *\n *\n * The [ElementInjector] can inject other directives, element-specific special objects, or it can delegate to the parent\n * injector.\n *\n * To inject other directives, declare the constructor parameter as:\n * - `directive:DirectiveType`: a directive on the current element only\n * - `@Ancestor() directive:DirectiveType`: any directive that matches the type between the current element and the\n *    Shadow DOM root. Current Element is not included in the resolution, therefor even if it could resolve it, it will\n *    be ignored.\n * - `@Parent() directive:DirectiveType`: any directive that matches the type on a direct parent element only.\n * - `@Children query:Query<DirectiveType>`: A live collection of direct child directives [TO BE IMPLEMENTED].\n * - `@Descendants query:Query<DirectiveType>`: A live collection of any child directives [TO BE IMPLEMENTED].\n *\n * To inject element-specific special objects, declare the constructor parameter as:\n * - `element: NgElement` to obtain a DOM element (DEPRECATED: replacment coming)\n * - `viewContainer: ViewContainer` to control child template instantiation, for [Viewport] directives only\n * - `bindingPropagation: BindingPropagation` to control change detection in a more granular way.\n *\n * ## Example\n *\n * The following example demonstrates how dependency injection resolves constructor arguments in practice.\n *\n *\n * Assume this HTML template:\n *\n * ```\n * <div dependency=\"1\">\n *   <div dependency=\"2\">\n *     <div dependency=\"3\" my-directive>\n *       <div dependency=\"4\">\n *         <div dependency=\"5\"></div>\n *       </div>\n *       <div dependency=\"6\"></div>\n *     </div>\n *   </div>\n * </div>\n * ```\n *\n * With the following `dependency` decorator and `SomeService` injectable class.\n *\n * ```\n * @Injectable()\n * class SomeService {\n * }\n *\n * @Decorator({\n *   selector: '[dependency]',\n *   bind: {\n *     'id':'dependency'\n *   }\n * })\n * class Dependency {\n *   id:string;\n * }\n * ```\n *\n * Let's step through the different ways in which `MyDirective` could be declared...\n *\n *\n * ### No injection\n *\n * Here the constructor is declared with no arguments, therefore nothing is injected into `MyDirective`.\n *\n * ```\n * @Decorator({ selector: '[my-directive]' })\n * class MyDirective {\n *   constructor() {\n *   }\n * }\n * ```\n *\n * This directive would be instantiated with no dependencies.\n *\n *\n * ### Component-level injection\n *\n * Directives can inject any injectable instance from the closest component injector or any of its parents.\n *\n * Here, the constructor declares a parameter, `someService`, and injects the `SomeService` type from the parent\n * component's injector.\n *\n * ```\n * @Decorator({ selector: '[my-directive]' })\n * class MyDirective {\n *   constructor(someService: SomeService) {\n *   }\n * }\n * ```\n *\n * This directive would be instantiated with a dependency on `SomeService`.\n *\n *\n * ### Injecting a directive from the current element\n *\n * Directives can inject other directives declared on the current element.\n *\n * ```\n * @Decorator({ selector: '[my-directive]' })\n * class MyDirective {\n *   constructor(dependency: Dependency) {\n *     expect(dependency.id).toEqual(3);\n *   }\n * }\n * ```\n * This directive would be instantiated with `Dependency` declared at the same element, in this case `dependency=\"3\"`.\n *\n *\n * ### Injecting a directive from a direct parent element\n *\n * Directives can inject other directives declared on a direct parent element. By definition, a directive with a\n * `@Parent` annotation does not attempt to resolve dependencies for the current element, even if this would satisfy\n * the dependency.\n *\n * ```\n * @Decorator({ selector: '[my-directive]' })\n * class MyDirective {\n *   constructor(@Parent() dependency: Dependency) {\n *     expect(dependency.id).toEqual(2);\n *   }\n * }\n * ```\n * This directive would be instantiated with `Dependency` declared at the parent element, in this case `dependency=\"2\"`.\n *\n *\n * ### Injecting a directive from any ancestor elements\n *\n * Directives can inject other directives declared on any ancestor element (in the current Shadow DOM), i.e. on the\n * parent element and its parents. By definition, a directive with an `@Ancestor` annotation does not attempt to\n * resolve dependencies for the current element, even if this would satisfy the dependency.\n *\n * ```\n * @Decorator({ selector: '[my-directive]' })\n * class MyDirective {\n *   constructor(@Ancestor() dependency: Dependency) {\n *     expect(dependency.id).toEqual(2);\n *   }\n * }\n * ```\n *\n * Unlike the `@Parent` which only checks the parent, `@Ancestor` checks the parent, as well as its\n * parents recursively. If `dependency=\"2\"` didn't exist on the direct parent, this injection would have returned\n * `dependency=\"1\"`.\n *\n *\n * ### Injecting a live collection of direct child directives [PENDING IMPLEMENTATION]\n *\n * A directive can also query for other child directives. Since parent directives are instantiated before child\n * directives, a directive can't simply inject the list of child directives. Instead, the directive asynchronously\n * injects a [Query], which updates as children are added, removed, or moved by any [ViewPort] directive such as a\n * `for`, an `if`, or a `switch`.\n *\n * ```\n * @Decorator({ selector: '[my-directive]' })\n * class MyDirective {\n *   constructor(@Children() dependencies:Query<Maker>) {\n *   }\n * }\n * ```\n *\n * This directive would be instantiated with a [Query] which contains `Dependency` 4 and 6. Here, `Dependency` 5 would\n * not be included, because it is not a direct child.\n *\n * ### Injecting a live collection of direct descendant directives [PENDING IMPLEMENTATION]\n *\n * Similar to `@Children` above, but also includes the children of the child elements.\n *\n * ```\n * @Decorator({ selector: '[my-directive]' })\n * class MyDirective {\n *   constructor(@Children() dependencies:Query<Maker>) {\n *   }\n * }\n * ```\n *\n * This directive would be instantiated with a Query which would contain `Dependency` 4, 5 and 6.\n *\n * ### Optional injection\n *\n * The normal behavior of directives is to return an error when a specified dependency cannot be resolved. If you\n * would like to inject `null` on unresolved dependency instead, you can annotate that dependency with `@Optional()`.\n * This explicitly permits the author of a template to treat some of the surrounding directives as optional.\n *\n * ```\n * @Decorator({ selector: '[my-directive]' })\n * class MyDirective {\n *   constructor(@Optional() dependency:Dependency) {\n *   }\n * }\n * ```\n *\n * This directive would be instantiated with a `Dependency` directive found on the current element. If none can be\n * found, the injector supplies `null` instead of throwing an error.\n *\n * @publicModule angular2/annotations\n */\n@ABSTRACT()\nexport class Directive extends Injectable {\n  /**\n   * The CSS selector that triggers the instantiation of a directive.\n   *\n   * Angular only allows directives to trigger on CSS selectors that do not cross element boundaries.\n   *\n   * `selector` may be declared as one of the following:\n   *\n   * - `element-name`: select by element name.\n   * - `.class`: select by class name.\n   * - `[attribute]`: select by attribute name.\n   * - `[attribute=value]`: select by attribute name and value.\n   * - `:not(sub_selector)`: select only if the element does not match the `sub_selector`.\n   * - `selector1, selector2`: select if either `selector1` or `selector2` matches.\n   *\n   *\n   * ## Example\n   *\n   * Suppose we have a directive with an `input[type=text]` selector.\n   *\n   * And the following HTML:\n   *\n   * ```html\n   * <form>\n   *   <input type=\"text\">\n   *   <input type=\"radio\">\n   * <form>\n   * ```\n   *\n   * The directive would only be instantiated on the `<input type=\"text\">` element.\n   *\n   */\n  selector:string;\n\n  /**\n   * Enumerates the set of properties that accept data binding for a directive.\n   *\n   * The `bind` property defines a set of `directiveProperty` to `bindingProperty` key-value pairs:\n   *\n   * - `directiveProperty` specifies the component property where the value is written.\n   * - `bindingProperty` specifies the DOM property where the value is read from.\n   *\n   * You can include [Pipes] when specifying a `bindingProperty` to allow for data transformation and structural\n   * change detection of the value. These pipes will be evaluated in the context of this component.\n   *\n   *\n   * ## Syntax\n   *\n   * ```\n   * @Directive({\n   *   bind: {\n   *     'directiveProperty1': 'bindingProperty1',\n   *     'directiveProperty2': 'bindingProperty2 | pipe1 | ...',\n   *     ...\n   *   }\n   * }\n   * ```\n   *\n   *\n   * ## Basic Property Binding\n   *\n   * We can easily build a simple `Tooltip` directive that exposes a `tooltip` property, which can be used in templates\n   * with standard Angular syntax. For example:\n   *\n   * ```\n   * @Decorator({\n   *   selector: '[tooltip]',\n   *   bind: {\n   *     'text': 'tooltip'\n   *   }\n   * })\n   * class Tooltip {\n   *   set text(text) {\n   *     // This will get called every time the 'tooltip' binding changes with the new value.\n   *   }\n   * }\n   * ```\n   *\n   * We can then bind to the `tooltip' property as either an expression (`someExpression`) or as a string literal, as\n   * shown in the HTML template below:\n   *\n   * ```html\n   * <div [tooltip]=\"someExpression\">...</div>\n   * <div tooltip=\"Some Text\">...</div>\n   * ```\n   *\n   * Whenever the `someExpression` expression changes, the `bind` declaration instructs Angular to update the\n   * `Tooltip`'s `tooltipText` property.\n   *\n   *\n   *\n   * ## Bindings With Pipes:\n   *\n   * You can also use pipes when writing binding definitions for a directive.\n   *\n   * For example, we could write a binding that updates the directive on structural changes, rather than on reference\n   * changes, as normally occurs in change detection. (See: [Pipe] and [keyValueDiff] documentaition for more details.)\n   *\n   * ```\n   * @Decorator({\n   *   selector: '[class-set]',\n   *   bind: {\n   *     'classChanges': 'classSet | keyValDiff'\n   *   }\n   * })\n   * class ClassSet {\n   *   set classChanges(changes:KeyValueChanges) {\n   *     // This will get called every time the `class-set` expressions changes its structure.\n   *   }\n   * }\n   * ```\n   *\n   * The template that this directive is used in may also contain its own pipes. For example:\n   *\n   * ```html\n   * <div [class-set]=\"someExpression | somePipe\">\n   * ```\n   *\n   * In this case, the two pipes compose as if they were inlined: `someExpression | somePipe | keyValDiff`.\n   *\n   */\n  bind:any; //  StringMap\n\n  /**\n   * Specifies which DOM events a directive listens to.\n   *\n   * The `events` property defines a set of `event` to `method` key-value pairs:\n   *\n   * - `event1`: the DOM event that the directive listens to.\n   * - `statement`: the statment to execute when the event occurs.\n   *\n   *\n   * When writing a directive event binding, you can also refer to the following local variables:\n   * - `$event`: Current event object which triggerd the event.\n   * - `$target`: The source of the event. This will be either a DOM element or an Angular directive.\n   *    [TO BE IMPLEMENTED]\n   *\n   *\n   * ## Syntax\n   *\n   * ```\n   * @Directive({\n   *   events: {\n   *     'event1': 'onMethod1(arguments)',\n   *     ...\n   *   }\n   * }\n   * ```\n   *\n   * ## Basic Event Binding:\n   *\n   * Suppose you want to write a directive that triggers on `change` events in the DOM. You would define the event\n   * binding as follows:\n   *\n   * ```\n   * @Decorator({\n   *   selector: 'input',\n   *   events: {\n   *     'change': 'onChange($event)'\n   *   }\n   * })\n   * class InputDecorator {\n   *   onChange(event:Event) {\n   *   }\n   * }\n   * ```\n   *\n   * Here `InputDecorator` is invoked whenever the DOM element fires the 'change' event.\n   *\n   */\n  events:any; //  StringMap\n\n  /**\n   * Specifies a set of lifecycle events in which the directive participates.\n   *\n   * See: [onChange], [onDestroy] for details.\n   */\n  lifecycle:List; //List<LifecycleEvent>\n\n  @CONST()\n  constructor({\n      selector,\n      bind,\n      events,\n      lifecycle\n    }:{\n      selector:string,\n      bind:any,\n      events: any,\n      lifecycle:List\n    }={})\n  {\n    super();\n    this.selector = selector;\n    this.bind = bind;\n    this.events = events;\n    this.lifecycle = lifecycle;\n  }\n\n  /**\n   * Returns true if a directive participates in a given [LifecycleEvent].\n   *\n   * See: [onChange], [onDestroy] for details.\n   */\n  hasLifecycleHook(hook:string):boolean {\n    return isPresent(this.lifecycle) ? ListWrapper.contains(this.lifecycle, hook) : false;\n  }\n}\n\n/**\n * Declare template views for an Angular application.\n *\n * Each angular component requires a single `@Component` and at least one `@Template` annotation. This allows Angular to\n * encapsulate state information and templates. These form the fundamental reusable building blocks for developing an\n * application. There can only be one component per DOM element.\n *\n * When a component is instantiated, Angular\n * - creates a shadow DOM for the component.\n * - loads the selected template into the shadow DOM.\n * - creates a child [Injector] which is configured with the [Component.services].\n *\n * All template expressions and statments are then evaluted against the component instance.\n *\n * For details on the `@Template` annotation, see [Template].\n *\n * ## Example\n *\n * ```\n * @Component({\n *   selector: 'greet'\n * })\n * @Template({\n *   inline: 'Hello {{name}}!'\n * })\n * class Greet {\n *   name: string;\n *\n *   constructor() {\n *     this.name = 'World';\n *   }\n * }\n * ```\n *\n * @publicModule angular2/annotations\n */\nexport class Component extends Directive {\n  /**\n   * Defines the set of injectable objects that are visible to a Component and its children.\n   *\n   * The [services] defined in the Component annotation allow you to configure a set of bindings for the component's\n   * injector.\n   *\n   * When a component is instantiated, Angular creates a new child Injector, which is configured with the bindings in\n   * the Component [services] annotation. The injectable objects then become available for injection to the component\n   * itself and any of the directives in the component's template, i.e. they are not available to the directives which\n   * are children in the component's light DOM.\n   *\n   *\n   * The syntax for configuring the [services] injectable is identical to [Injector] injectable configuration. See\n   * [Injector] for additional detail.\n   *\n   *\n   * ## Simple Example\n   *\n   * Here is an example of a class that can be injected:\n   *\n   * ```\n   * class Greeter {\n   *    greet(name:string) {\n   *      return 'Hello ' + name + '!';\n   *    }\n   * }\n   *\n   * @Component({\n   *   selector: 'greet',\n   *   services: [\n   *     Greeter\n   *   ]\n   * })\n   * @Template({\n   *   inline: `{{greeter.greet('world')}}!`,\n   *   directives: Child\n   * })\n   * class HelloWorld {\n   *   greeter:Greeter;\n   *\n   *   constructor(greeter:Greeter) {\n   *     this.greeter = greeter;\n   *   }\n   * }\n   * ```\n   */\n  services:List;\n\n@CONST()\n  constructor({\n    selector,\n    bind,\n    events,\n    services,\n    lifecycle\n    }:{\n      selector:String,\n      bind:Object,\n      events:Object,\n      services:List,\n      lifecycle:List\n    }={})\n  {\n    super({\n      selector: selector,\n      bind: bind,\n      events: events,\n      lifecycle: lifecycle\n    });\n\n    this.services = services;\n  }\n}\n\n/**\n * A directive used for dynamically loading components.\n *\n * Regular angular components are statically resolved. DynamicComponent allows to you resolve a component at runtime\n * instead by providing a placeholder into which a regular angular component can be dynamically loaded. Once loaded,\n * the dynamically-loaded component becomes permanent and cannot be changed.\n *\n *\n * ## Example\n *\n * Here we have `DynamicComp` which acts as the placeholder for `HelloCmp`. At runtime, the dynamic component\n * `DynamicComp` requests loading of the `HelloCmp` component.\n *\n * There is nothing special about `HelloCmp`, which is a regular angular component. It can also be used in other static\n * locations.\n *\n * ```\n * @DynamicComponent({\n *   selector: 'dynamic-comp'\n * })\n * class DynamicComp {\n *   helloCmp:HelloCmp;\n *   constructor(loader:PrivateComponentLoader, location:PrivateComponentLocation) {\n *     loader.load(HelloCmp, location).then((helloCmp) => {\n *       this.helloCmp = helloCmp;\n *     });\n *   }\n * }\n *\n * @Component({\n *   selector: 'hello-cmp'\n * })\n * @Template({\n *   inline: \"{{greeting}}\"\n * })\n * class HelloCmp {\n *   greeting:string;\n *   constructor() {\n *     this.greeting = \"hello\";\n *   }\n * }\n * ```\n *\n *\n *\n * @publicModule angular2/annotations\n */\nexport class DynamicComponent extends Directive {\n  /**\n   * Same as [Component.services].\n   */\n  // TODO(vsankin): Please extract into AbstractComponent\n  services:any; //List;\n\n  @CONST()\n  constructor({\n    selector,\n    bind,\n    events,\n    services,\n    lifecycle\n    }:{\n      selector:string,\n      bind:Object,\n      events:Object,\n      services:List,\n      lifecycle:List\n    }={}) {\n    super({\n      selector: selector,\n      bind: bind,\n      events: events,\n      lifecycle: lifecycle\n    });\n\n    this.services = services;\n  }\n}\n\n/**\n * Directive that attaches behavior to DOM elements.\n *\n * A decorator directive attaches behavior to a DOM element in a composable manner. \n * (see: http://en.wikipedia.org/wiki/Composition_over_inheritance)\n * \n * Decorators:\n * - are simplest form of [Directive]s.\n * - are best used as a composition pattern ()\n *\n * Decorators differ from [Component]s in that they:\n * - can have multiple decorators per element\n * - do not create their own evaluation context\n * - do not have template (and therefor do not create Shadow DOM)\n *\n *\n * ## Example\n *\n * Here we use a decorator directive to simply define basic tool-tip behavior. \n *\n * ```\n * @Decorator({\n *   selector: '[tooltip]',\n *   bind: {\n *     'text': 'tooltip'\n *   },\n *   event: {\n *     'onmouseenter': 'onMouseEnter()',\n *     'onmouseleave': 'onMouseLeave()'\n *   }\n * })\n * class Tooltip{\n *   text:string;\n *   overlay:Overlay; // NOT YET IMPLEMENTED\n *   overlayManager:OverlayManager; // NOT YET IMPLEMENTED\n *\n *   constructor(overlayManager:OverlayManager) {\n *     this.overlay = overlay;\n *   }\n *\n *   onMouseEnter() {\n *     // exact signature to be determined\n *     this.overlay = this.overlayManager.open(text, ...);\n *   }\n *\n *   onMouseLeave() {\n *     this.overlay.close();\n *     this.overlay = null;\n *   }\n * }\n * ```\n * In our HTML template, we can then add this behavior to a `<div>` or any other element with the `tooltip` selector, \n * like so:\n * \n *  ```\n * <div tooltip=\"some text here\"></div>\n * ```\n *\n * @publicModule angular2/annotations\n */\nexport class Decorator extends Directive {\n\n  /**\n   * If set to true the compiler does not compile the children of this directive.\n   */\n  //TODO(vsavkin): This would better fall under the Macro directive concept.\n  compileChildren: boolean;\n\n  @CONST()\n  constructor({\n      selector,\n      bind,\n      events,\n      lifecycle,\n      compileChildren = true,\n    }:{\n      selector:string,\n      bind:any,\n      events:any,\n      lifecycle:List,\n      compileChildren:boolean\n    }={})\n  {\n    this.compileChildren = compileChildren;\n    super({\n        selector: selector,\n        bind: bind,\n        events: events,\n        lifecycle: lifecycle\n    });\n  }\n}\n\n/**\n * Viewport is used for controlling the instatiation of inline templates. [TODO: needs co-work :)]\n *\n * Viewport consist of a controller which can inject [ViewContainer]. A [ViewContainer] represents a location in the\n * current view where child views can be inserted. [ViewContainer] is created as a result of `<template>` element.\n *\n * NOTE: `<template>` directives can be created in shorthand form as `<TAG template=\"...\">` or `<TAG *key=\"...\">`\n *\n * ## Example\n *\n * Given folowing inline template, let's implement the `unless` behavior.\n *\n * ```\n * <ul>\n *   <li *unless=\"expr\"></li>\n * </ul>\n * ```\n *\n * Can be implemented using:\n *\n * ```\n * @Viewport({\n *   selector: '[unless]',\n *   bind: {\n *     'condition': 'unless'\n *   }\n * })\n * export class If {\n *   viewContainer: ViewContainer;\n *   prevCondition: boolean;\n *\n *   constructor(viewContainer: ViewContainer) {\n *     this.viewContainer = viewContainer;\n *     this.prevCondition = null;\n *   }\n *\n *   set condition(newCondition) {\n *     if (newCondition && (isBlank(this.prevCondition) || !this.prevCondition)) {\n *       this.prevCondition = true;\n *       this.viewContainer.clear();\n *     } else if (!newCondition && (isBlank(this.prevCondition) || this.prevCondition)) {\n *       this.prevCondition = false;\n *       this.viewContainer.create();\n *     }\n *   }\n * }\n * ```\n *\n * To better undarstand what is hapening, remember that angular converts the above template to:\n *\n * ```\n * <ul>\n *   <template [unless]=\"exp\">\n *     <li></li>\n *   </template>\n * </ul>\n * ```\n *\n * Notice that the `*unless=\"exp\"` got hoisted to `<template>`. This means that the `Viewport` controller is instantiated\n * on the `<template>` element rather thna the `<li>` element.\n *\n * Once the viewport insntantiates the child view the result is:\n *\n * ```\n * <ul>\n *   <template [unless]=\"exp\">\n *     <li></li>\n *   </template>\n *   <li></li>\n * </ul>\n * ```\n *\n * The key thing to notice here is that `<li>` instance is a sibling of `<template>` not a child. For this reason\n * it is not possible to inject `Viewport` directive into other directives, (`Viweport` directives are always on\n * `<template>` elements which are leafs.)\n *\n *\n * @publicModule angular2/annotations\n */\nexport class Viewport extends Directive {\n  @CONST()\n  constructor({\n      selector,\n      bind,\n      events,\n      lifecycle\n    }:{\n      selector:string,\n      bind:any,\n      lifecycle:List\n    }={})\n  {\n    super({\n        selector: selector,\n        bind: bind,\n        events: events,\n        lifecycle: lifecycle\n    });\n  }\n}\n\n//TODO(misko): turn into LifecycleEvent class once we switch to TypeScript;\n\n/**\n * Specify that a directive should be notified whenever a [View] that contains it is destroyed.\n *\n * ## Example\n *\n * ```\n * @Decorator({\n *   ...,\n *   lifecycle: [ onDestroy ]\n * })\n * class ClassSet implements OnDestroy {\n *   onDestroy() {\n *     // invoked to notify directive of the containing view destruction.\n *   }\n * }\n * ```\n * @publicModule angular2/annotations\n */\nexport const onDestroy = \"onDestroy\";\n\n\n/**\n * Specify that a directive should be notified when any of its bindings have changed.\n *\n * ## Example:\n *\n * ```\n * @Decorator({\n *   selector: '[class-set]',\n *   bind: {\n *     'propA': 'propA'\n *     'propB': 'propB'\n *   }\n * })\n * class ClassSet {\n *   propA;\n *   propB;\n *   onChange(changes:{[idx: string, PropertyUpdate]}) {\n *     // This will get called after any of the properties have been updated.\n *     if (changes['propA']) {\n *       // if propA was updated\n *     }\n *     if (changes['propA']) {\n *       // if propB was updated\n *     }\n *   }\n * }\n *  ```\n * @publicModule angular2/annotations\n */\nexport const onChange = \"onChange\";\n","$traceurRuntime.superConstructor($__placeholder__0).call($__placeholder__1)","Object.defineProperty($__placeholder__0, $__placeholder__1,\n        {get: function() {return $__placeholder__2}});","assert.type.$__placeholder__0)","($__placeholder__0 = $__placeholder__1.$__placeholder__2) === void 0 ?\n        $__placeholder__3 : $__placeholder__4","$__export($__placeholder__0, $__placeholder__1)"]}